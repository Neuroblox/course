<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/course/libs/highlight/styles/github.min.css"> <link href="/course/css/franklin.css" rel=stylesheet > <link href="/course/css/vela.css" rel=stylesheet > <script src="/course/libs/vela/jquery.min.js"></script> <link rel=icon  href="/course/assets/NB_favicon.png"> <title>Neuroblox course</title> <div class="main-nav slideout-menu slideout-menu-left" id=menu > <div class=flex-container > <span class=sidebar-brand > <h3 style='font-size: 25px'>Neuroblox course</h3> </span> </div> <nav class=sidebar-nav > <ul class=metismenu  id=metismenu  > <li><a href="/course/index.html">Home</a> <li><a href="/course/pages/getting_started">Getting Started</a> <li><a href="/course/pages/intro_julia">Introduction to Julia</a> <li><a href="/course/pages/intro_diffeq">Differential Equations with ModelingToolkit</a> <li><a href="/course/pages/intro_plot">Plotting with Makie</a> <li><a href="/course/pages/blox_connections">Blox and Connections in Neuroblox</a> <li><a href="/course/pages/neuron_mass">Neurons, Neural Masses and Sources</a> <li><a href="" class=has-arrow >Circuit Models</a> <ul> <li><a href="/course/pages/circuits">Introduction</a> <li><a href="/course/pages/CS_circuit">Biomimetic Corticostriatal assemblies</a> <li><a href="/course/pages/PING_circuit">Pyramidal-Interneuron Gamma network</a> </ul> <li><a href="/course/pages/decision_making">Decision Making</a> <li><a href="/course/pages/learning">Synaptic Plasticity and Reinforcement Learning</a> <li><a href="/course/pages/DCM">Spectral Dynamic Causal Modeling</a> </ul> </nav> </div> <main id=panel  class="slidout-panel slideout-panel-left"> <div class="toggle-button hamburger hamburger--spin"> <div class=hamburger-box > <div class=hamburger-inner ></div> </div> </div> <h1 class="page title">Blox and Connections in Neuroblox</h1> <hr> <div class=franklin-content ><div class=franklin-toc ><ol><li><a href="#introduction">Introduction</a><li><a href="#type_hierarchy">Type hierarchy</a><li><a href="#inspecting_a_blox">Inspecting a Blox</a><li><a href="#inspecting_a_connection_between_bloxs">Inspecting a connection between Bloxs</a><li><a href="#simulating_connected_bloxs">Simulating connected Bloxs</a><li><a href="#custom_blox">Custom Blox</a><li><a href="#custom_connections">Custom Connections</a><ol><li><a href="#connection_equations">Connection equations</a><li><a href="#connection_callbacks">Connection callbacks</a></ol><li><a href="#challenge_problems">Challenge Problems</a></ol></div> <h1 id=blox_and_connections_in_neuroblox ><a href="#blox_and_connections_in_neuroblox" class=header-anchor >Blox and Connections in Neuroblox</a></h1> <blockquote> <p><strong><em>Jupyter Notebook</em>:</strong> Please work on <code>blox_connections.ipynb</code>.</p> </blockquote> <h2 id=introduction ><a href="#introduction" class=header-anchor >Introduction</a></h2> <p>Neuroblox comes with a library of many components already, which we call Blox. Such Blox are neuron models, neural masses, circuits of these, input sources, observers etc. Additionally there are connection rules that dictate how types of components connect with one another. Over the rest of this course we will encounter multiple examples of models made by Neuroblox components and connected by rules already implemented in the package.</p> <p>It is also possible though to design custom Blox components and connection rules that do not exist in Neuroblox yet. This feature allows us to easily extend the capabilities of Neuroblox towards our specific needs.</p> <p>Here we will learn how to define our own Blox components and write down connection rules to allow our Blox to connect to ones within Neuroblox.</p> <p>Learning goals:</p> <ul> <li><p>Learn about how Bloxs and their connections are structured in Neuroblox.</p> <li><p>Implement new Bloxs in code.</p> <li><p>Implement new connection rules between the new Bloxs and existing ones from Neuroblox.</p> </ul> <h2 id=type_hierarchy ><a href="#type_hierarchy" class=header-anchor >Type hierarchy</a></h2> <p>Neuroblox organizes its Bloxs into type hierarchies. There is <code>AbstractBlox</code> at the top level and then <code>Neuron</code> and <code>NeuralMass</code> that are subtypes of it. Then there are <code>ExciNeuron</code> and <code>InhNeuron</code> which are subtypes of <code>Neuron</code> specifically for Bloxs with excitatory and inhibitory dynamics respectively. This structure is important for defining connection rules, plotting recipes and other utility functions by exploiting Julia&#39;s multiple dispatch capabilities. For instance if we define a new Blox that is <code>&lt;: Neuron</code> then we do not need to define all the functions necessary to connect such a Blox to other Bloxs or to plot results after simulating it. There is a generic connection rule in Neuroblox already between <code>Neuron</code> Bloxs that will be employed if no specific rule is provided. Similarly there are recipes of how to generate raster plots, firing rate plots etc for any Blox that is a subtype of <code>Neuron</code>.</p> <h2 id=inspecting_a_blox ><a href="#inspecting_a_blox" class=header-anchor >Inspecting a Blox</a></h2> <p>Neuroblox includes several functions to inspect a Blox, its equations, variables &#40;unknowns&#41;, parameters, inputs, outputs and events, much like a <code>ModelingToolkit</code> model. These functions are useful given that there is a great range of Bloxs in Neuroblox and we might want to utilize some of them when we build a model. So before adding Bloxs to our model we can learn more about them. For example let&#39;s consider a <code>LIFNeuron</code>, which is a Leaky Integrate-and-Fire &#40;LIF&#41; neuron in Neuroblox.</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> Neuroblox
<span class=hljs-keyword >using</span> OrdinaryDiffEq

<span class=hljs-meta >@named</span> lif = LIFNeuron()

<span class=hljs-meta >@show</span> typeof(lif)
<span class=hljs-meta >@show</span> lif <span class=hljs-keyword >isa</span> Neuron <span class=hljs-comment ># equivalent to typeof(lif) &lt;: Neuron</span>

unknowns(lif)
parameters(lif)
inputs(lif)
outputs(lif)
discrete_events(lif)
equations(lif)</code></pre><pre><code class="plaintext hljs">typeof(lif) = Neuroblox.LIFNeuron
lif isa Neuron = true
2-element Vector{Symbolics.Equation}:
 Differential(t)(V(t)) ~ (I_in + (Eₘ - V(t)) / Rₘ + jcn(t)) / C
 Differential(t)(G(t)) ~ (-G(t)) / τ</code></pre> <p>Using these functions we can learn everything about a Blox that will be useful when we want to use it or connect our own custom Bloxs to it.</p> <h2 id=inspecting_a_connection_between_bloxs ><a href="#inspecting_a_connection_between_bloxs" class=header-anchor >Inspecting a connection between Bloxs</a></h2> <p>Getting information about how two Bloxs connect is equally important to inspecting the Bloxs themselves. There are two functions in Neuroblox that help us gain more information about a connection. The first one will print only the connection equations</p> <pre><code class="julia hljs"><span class=hljs-meta >@named</span> ifn = IFNeuron() <span class=hljs-comment >## create an Integrate-and-Fire neuron, simpler than the `LIFNeuron`</span>

connection_equations(lif, ifn, weight=<span class=hljs-number >1</span>, connection_rule=<span class=hljs-string >&quot;basic&quot;</span>)</code></pre><pre><code class="plaintext hljs">1-element Vector{Symbolics.Equation}:
 ifn₊jcn(t) ~ w_lif_ifn*lif₊G(t)</code></pre> <p>While the second function prints out all fields that take part in the connection rule</p> <pre><code class="julia hljs">connection_rule(lif, ifn, weight=<span class=hljs-number >1</span>, connection_rule=<span class=hljs-string >&quot;psp&quot;</span>)</code></pre><pre><code class="plaintext hljs">Connections :
	 lif =&gt; ifn
Equations :
	 ifn₊jcn(t) ~ (lif₊E_syn - ifn₊V(t))*w_lif_ifn*lif₊G(t)
Weights :
	 w_lif_ifn
</code></pre> <p>The <code>weight</code> and <code>connection_rule</code> are keyword arguments that can be ommitted. If we ommit them then we will get a message informing us about the default values that they take. The <code>connection_rule</code> argument applies to connections between <code>Neuron</code> types; <code>&quot;basic&quot;</code> is a simple weighted connection and <code>&quot;psp&quot;</code> applies a postsynaptic potential type of connection. The output of both <code>connection_equations</code> and <code>connection_rule</code> functions now seems very similar. However <code>connection_rule</code> will be more useful later on when we start using more complex Bloxs and connection rules that do more than just adding an equation and a symbolic weight.</p> <h2 id=simulating_connected_bloxs ><a href="#simulating_connected_bloxs" class=header-anchor >Simulating connected Bloxs</a></h2> <p>We are now ready to define a couple of Bloxs, connect them and simulate the final model. Every Neuroblox model starts off as a graph. Every vertex of the graph is a Blox and every edge is a connection between two Bloxs. Let&#39;s build a simple circuit by using the two neurons we created above; <code>lif</code> connects to <code>ifn</code>.</p> <pre><code class="julia hljs">g = MetaDiGraph()
add_edge!(g, lif =&gt; ifn, weight=<span class=hljs-number >1</span>) <span class=hljs-comment >## add connection with specific weight value</span>

<span class=hljs-meta >@named</span> sys = system_from_graph(g)
prob = ODEProblem(sys, [], (<span class=hljs-number >0</span>, <span class=hljs-number >200.0</span>))
sol = solve(prob, Tsit5());</code></pre> <p><code>system_from_graph</code> is the workhorse in Neuroblox that turns a graph to a system of differential equations. It performs <code>structural_simplify</code> internally too, so the rest of the lines are the same as for a <code>ModelingToolkit</code> model.</p> <h2 id=custom_blox ><a href="#custom_blox" class=header-anchor >Custom Blox</a></h2> <p>We will implement the Izhikevich neuron from the previous session into a Blox. Every Blox is a Julia <code>struct</code> that needs to contain at least two fields</p> <ul> <li><p><code>system</code> that holds the dynamics of the Blox.</p> <li><p><code>namespace</code> that holds the namespace to which the object belongs. This field is not relevant for the current session and it will be left to its default value of <code>namespace&#61;nothing</code>. Namespaces are important in hierarchical models though, where we have Bloxs that contain other Bloxs in them. We will see such an example later on.</p> </ul> <p>We will only include these two fields and write an inner constructor function for our <code>struct IzhNeuron</code>.</p> <pre><code class="julia hljs"><span class=hljs-keyword >struct</span> IzhNeuron &lt;: Neuron
    system
    namespace

    <span class=hljs-keyword >function</span> IzhNeuron(; name, namespace=<span class=hljs-literal >nothing</span>, a=<span class=hljs-number >0.02</span>, b=<span class=hljs-number >0.2</span>, V_reset=-<span class=hljs-number >50</span>, d=<span class=hljs-number >2</span>, threshold=<span class=hljs-number >30</span>)
        sts = <span class=hljs-meta >@variables</span> V(t)=-<span class=hljs-number >65</span> [output=<span class=hljs-literal >true</span>] u(t)=-<span class=hljs-number >13</span> jcn [input=<span class=hljs-literal >true</span>]
        params = <span class=hljs-meta >@parameters</span> a=a b=b V_reset=V_reset d=d θ=threshold

        eqs = [D(V) ~ <span class=hljs-number >0.04</span> * V ^ <span class=hljs-number >2</span> + <span class=hljs-number >5</span> * V + <span class=hljs-number >140</span> - u + jcn + <span class=hljs-number >5</span>,
                D(u) ~ a * (b * V - u)]

        event = (V &gt; θ) =&gt; [u ~ u + d, V ~ V_reset]
        sys = System(eqs, t, sts, params; name=name, discrete_events = event)

        new(sys, namespace)
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span>

<span class=hljs-comment ># In the `IzhNeuron` constructor function we keep all arguments as keyword arguments so that we can set them more conveniently as `arg = value`. Spike threshold `θ=30` is now included as a parameter. Default values for all parameters are the keyword arguments from above. This way we can set them easily during construction.</span></code></pre> <blockquote> <p><strong><em>NOTE</em>:</strong> In <code>IzhNeuron</code> the <code>jcn</code> variable does not get a default value, only the &#91;input&#61;true&#93; tag. This means that other Bloxs will connect to a <code>IzhNeuron</code> through <code>jcn</code>.</p> <p>Neuroblox automatically initializes a <code>jcn ~ 0</code> equation and then accumulates connection terms in it. This happens with all input variables of Bloxs.</p> <p>Similarly the <code>&#91;output&#61;true&#93;</code> tag designates the <code>V</code> variable as the output variable. It is necessary for every Blox to have one if they rely on generic connection rules that fetch the output variable and add it to the connection equation.</p> <p>Both input and output tags are also useful to note which variables should be used when writing connection rules to or from our Blox.</p> </blockquote> <p>Now we are ready to define the first object of <code>IzhNeuron</code> and connect it with the <code>LIFNeuron</code> we created above.</p> <pre><code class="julia hljs"><span class=hljs-meta >@named</span> izh = IzhNeuron()</code></pre><pre><code class="plaintext hljs">IzhNeuron(ModelingToolkit.ODESystem(0x0000000000001fe8, Symbolics.Equation[Differential(t)(V(t)) ~ 145 + jcn - u(t) + 5V(t) + 0.04(V(t)^2), Differential(t)(u(t)) ~ a*(-u(t) + b*V(t))], t, SymbolicUtils.BasicSymbolic{Real}[V(t), u(t), jcn], SymbolicUtils.BasicSymbolic{Real}[a, b, V_reset, d, θ], nothing, Dict{Any, Any}(:a =&gt; a, :b =&gt; b, :d =&gt; d, :V =&gt; V(t), :jcn =&gt; jcn, :u =&gt; u(t), :θ =&gt; θ, :V_reset =&gt; V_reset), Any[], Symbolics.Equation[], Base.RefValue{Vector{Symbolics.Num}}(Symbolics.Num[]), Base.RefValue{Any}(Matrix{Symbolics.Num}(undef, 0, 0)), Base.RefValue{Any}(Matrix{Symbolics.Num}(undef, 0, 0)), Base.RefValue{Matrix{Symbolics.Num}}(Matrix{Symbolics.Num}(undef, 0, 0)), Base.RefValue{Matrix{Symbolics.Num}}(Matrix{Symbolics.Num}(undef, 0, 0)), :izh, &quot;&quot;, ModelingToolkit.ODESystem[], Dict{Any, Any}(a =&gt; 0.02, V_reset =&gt; -50, d =&gt; 2, u(t) =&gt; -13, V(t) =&gt; -65.0, b =&gt; 0.2, θ =&gt; 30), Dict{Any, Any}(), nothing, nothing, Symbolics.Equation[], nothing, nothing, nothing, ModelingToolkit.SymbolicContinuousCallback[], ModelingToolkit.SymbolicDiscreteCallback[condition: V(t) &gt; θ
affects:
  u(t) ~ d + u(t)
  V(t) ~ V_reset
], Symbolics.Equation[], nothing, nothing, false, Any[], nothing, nothing, false, nothing, nothing, nothing, nothing, nothing), nothing)</code></pre> <p>One benefit of assigning <code>IzhNeuron &lt;: Neuron</code> is now apparent. Without defining a new connection equation for it, <code>IzhNeuron</code> can connect to <code>LIFNeuron</code> and to any other neuron type using a generic connection equation in Neuroblox. We can see what this equation looks like by running</p> <pre><code class="julia hljs">connection_equations(izh, lif, weight=<span class=hljs-number >1</span>, connection_rule=<span class=hljs-string >&quot;basic&quot;</span>) <span class=hljs-comment >## connection from izh to lif</span>
connection_equations(lif, izh, weight=<span class=hljs-number >1</span>, connection_rule=<span class=hljs-string >&quot;basic&quot;</span>) <span class=hljs-comment >## connection from lif to izh</span></code></pre><pre><code class="plaintext hljs">1-element Vector{Symbolics.Equation}:
 izh₊jcn ~ w_lif_izh*lif₊G(t)</code></pre> <p>We even get a warning saying that the connection rule is not specified so Neuroblox defaults to this basic weighted connection.</p> <h2 id=custom_connections ><a href="#custom_connections" class=header-anchor >Custom Connections</a></h2> <p>Often times genric connection rules are not sufficient and we need ones specialized to our custom Bloxs. There are two elements that allow for great customization variety when it comes to connection rules, connection equations and callbacks.</p> <h3 id=connection_equations ><a href="#connection_equations" class=header-anchor >Connection equations</a></h3> <p>Let&#39;s define a custom equation that connects a <code>LIFNeuron</code> to our <code>IzhNeuron</code>. The first thing we need to do is to import the <code>connection_equations</code> function from Neuroblox so that we can add a new dispatch to it.</p> <pre><code class="julia hljs"><span class=hljs-keyword >import</span> Neuroblox: connection_equations

<span class=hljs-keyword >function</span> connection_equations(source::LIFNeuron, destination::IzhNeuron, weight; kwargs...)
    equation = destination.jcn ~ weight * source.G * (destination.V - source.E_syn)

    <span class=hljs-keyword >return</span> equation
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">connection_equations (generic function with 4 methods)</code></pre>
<p>Internally Neuroblox will call the function dispatch with the most specific combination of its input arguments. Before defining the function above there was no dispatch that had <code>IzhNeuron</code> in its signature so Neuroblox defaulted to the connection we saw above. Now that we have defined a specialized equation, we can connect the same two Bloxs in a new way.</p>
<pre><code class="julia hljs">connection_equations(lif, izh, weight=<span class=hljs-number >1</span>, connection_rule=<span class=hljs-string >&quot;basic&quot;</span>)</code></pre><pre><code class="plaintext hljs">1-element Vector{Symbolics.Equation}:
 izh₊jcn ~ (-lif₊E_syn + izh₊V(t))*w_lif_izh*lif₊G(t)</code></pre>
<p>Notice how the equation has changed compared to above and it is equal to our latest <code>connection_equations</code> dispatch.</p>
<blockquote>
<p><strong><em>NOTE</em>:</strong> When we define a new <code>connection_equations</code> dispatch we need to include three positional arguments, the source Blox, the destination Blox and a symbolic weight parameter that is generated internally in Neuroblox and assigned to a specific connection.</p>
<p>We also include <code>kwargs...</code> which reads as an arbitrary number of keyword arguments. This is a placeholder for additional arguments that either Neuroblox uses internally or we want to pass as equation terms. We will see an example of the latter shortly.</p>
<p>When we call <code>connection_equations&#40;lif, izh&#41;</code> to print out the relevant equations we don&#39;t have to include the <code>weight</code> since it is currently not generated.</p>
</blockquote>
<pre><code class="julia hljs">g = MetaDiGraph()
<span class=hljs-comment ># Also set the weight value this time</span>
add_edge!(g, izh =&gt; lif, weight = <span class=hljs-number >1</span>)

<span class=hljs-meta >@named</span> sys = system_from_graph(g)
prob = ODEProblem(sys, [], (<span class=hljs-number >0</span>, <span class=hljs-number >200.0</span>))
sol = solve(prob, Tsit5());</code></pre>
<p>We can add as many keyword arguments as we want to our <code>connection_equations</code> dispatch. Such arguments can be used as additional terms to the equations. Here we add a constant current <code>const_current</code> to the equations above.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> connection_equations(source::IzhNeuron, destination::LIFNeuron, weight; const_current=<span class=hljs-number >1</span>, kwargs...)
    equation = destination.jcn ~ weight * source.V + const_current

    <span class=hljs-keyword >return</span> equation
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">connection_equations (generic function with 5 methods)</code></pre>
<p>Now we can set <code>const_current</code> to any value we want each time we make a connection that uses it.</p>
<pre><code class="julia hljs">g = MetaDiGraph()
<span class=hljs-comment ># Set const_current to a value that is other than its default.</span>
add_edge!(g, izh =&gt; lif; weight = <span class=hljs-number >1</span>, const_current=<span class=hljs-number >20</span>)

<span class=hljs-meta >@named</span> sys = system_from_graph(g)
prob = ODEProblem(sys, [], (<span class=hljs-number >0</span>, <span class=hljs-number >200.0</span>))
sol = solve(prob, Tsit5());</code></pre>
<blockquote>
<p><strong><em>Exercise:</em></strong> Define another connection equation from a <code>LIFNeuron</code> to an <code>IzhNeuron</code>, then create a graph with one connection of this kind and simulate it.</p>
</blockquote>
<h3 id=connection_callbacks ><a href="#connection_callbacks" class=header-anchor >Connection callbacks</a></h3>
<p>Algebraic connection equations is not the only way that a blox can interact with another one. Discrete callbacks are also possible. These callbacks will be applied at every timepoint during simulation where the callback condition is fulfilled. This mechanism is particularly useful for neuron models like the Izhikevich and the LIF neurons we saw above that use callbacks to implement spiking.</p>
<blockquote>
<p><strong><em>NOTE</em>:</strong> The affect equations of a single event can change either only variables or parameters. Currently we can not mix variable and parameter changes within the same event. See the <a href="https://docs.sciml.ai/ModelingToolkit/stable/basics/Events/#Discrete-events-support">ModelingToolkit documentation</a> for more details.</p>
</blockquote>
<pre><code class="julia hljs"><span class=hljs-keyword >import</span> Neuroblox: connection_callbacks

<span class=hljs-keyword >function</span> connection_callbacks(source::IzhNeuron, destination::LIFNeuron; spike_conductance=<span class=hljs-number >1</span>, kwargs...)
    spike_affect = (source.V &gt; source.θ) =&gt; [destination.G ~ destination.G + spike_conductance]

    <span class=hljs-keyword >return</span> spike_affect
<span class=hljs-keyword >end</span>

g = MetaDiGraph()
add_edge!(g, izh =&gt; lif, weight = <span class=hljs-number >1</span>)

<span class=hljs-meta >@named</span> sys = system_from_graph(g)

prob = ODEProblem(sys, [], (<span class=hljs-number >0</span>, <span class=hljs-number >200.0</span>))
sol = solve(prob, Tsit5());</code></pre>
<p>Exactly like <code>connection_equations</code>, when we define a <code>connection_callbacks</code> dispatch we add <code>kwargs...</code> to be used internally by Neuroblox and any other keyword arguments that we use in our callbacks. Here we have added <code>spike_conductance</code> as the value that increments the conductance <code>G</code> after each spike.</p>
<blockquote>
<p><strong><em>Exercise:</em></strong> Define a <code>connection_callbacks</code> function from a <code>LIFNeuron</code> to an <code>IzhNeuron</code> then create a graph with one connection of this kind and simulate it. Consider which variable or parameter of <code>IzhNeuron</code> should be affected by such a spike. Hint: Look at how a <code>IzhNeuron</code> spike affects its own dynamics.</p>
</blockquote>
<h2 id=challenge_problems ><a href="#challenge_problems" class=header-anchor >Challenge Problems</a></h2>
<ul>
<li><p>Implement a Morris-Lecar neuron as a new Blox and add connection rules to interface it with itself and Hodgkin-Huxley neurons from Neuroblox &#40;<code>HHNeuronExciBlox</code> and <code>HHNeuronInhibBlox</code>&#41;.</p>
<ul>
<li><p>Morris C, Lecar H. Voltage oscillations in the barnacle giant muscle fiber. Biophys J. 1981 Jul;35&#40;1&#41;:193-213. doi: 10.1016/S0006-3495&#40;81&#41;84782-0. PMID: 7260316; PMCID: PMC1327511.</p>

<li><p>http://www.scholarpedia.org/article/Morris-Lecar_model</p>

</ul>

<li><p>Implement a spiking neural network of Generalized Leaky Integrate-and-Fire neurons. Section 2.1 from the paper.</p>
<ul>
<li><p>Lorenzi RM, Geminiani A, Zerlaut Y, De Grazia M, Destexhe A, Gandini Wheeler-Kingshott CAM, Palesi F, Casellato C, D&#39;Angelo E. A multi-layer mean-field model of the cerebellum embedding microstructure and population-specific dynamics. PLoS Comput Biol. 2023 Sep 1;19&#40;9&#41;:e1011434. doi: 10.1371/journal.pcbi.1011434. PMID: 37656758; PMCID: PMC10501640.</p>

</ul>

<li><p>Implement a Hopf network model with stochastic dynamics.</p>
<ul>
<li><p>Ponce-Alvarez, A., Deco, G. The Hopf whole-brain model and its linear approximation. Sci Rep 14, 2615 &#40;2024&#41;. https://doi.org/10.1038/s41598-024-53105-0</p>

</ul>

</ul>

<div class=page-foot >
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Neuroblox Inc. Last modified: January 15, 2025.
    Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
</div>
</div>
  </main> 
  <script src="/course/libs/vela/metisMenu.min.js"></script>
  <script src="/course/libs/vela/slideout.min.js"></script>
  
  
    <script src="/course/libs/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();hljs.configure({tabReplace: '    '});</script>