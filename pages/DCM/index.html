<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/course/libs/katex/katex.min.css"> <link rel=stylesheet  href="/course/libs/highlight/styles/github.min.css"> <link href="/course/css/franklin.css" rel=stylesheet > <link href="/course/css/vela.css" rel=stylesheet > <script src="/course/libs/vela/jquery.min.js"></script> <link rel=icon  href="/course/assets/new_favicon.png"> <title>Neuroblox course</title> <div class="main-nav slideout-menu slideout-menu-left" id=menu > <div class=flex-container > <span class=sidebar-brand > <h3 style='font-size: 25px'>Neuroblox course</h3> </span> </div> <nav class=sidebar-nav > <ul class=metismenu  id=metismenu  > <li><a href="/course/index.html">Home</a> <li><a href="/course/pages/getting_started">Getting Started</a> <li><a href="/course/pages/intro_julia">Introduction to Julia</a> <li><a href="/course/pages/intro_diffeq">Differential Equations with ModelingToolkit</a> <li><a href="/course/pages/intro_plot">Plotting with Makie</a> <li><a href="/course/pages/blox_connections">Blox and Connections in Neuroblox</a> <li><a href="/course/pages/neuron_mass">Neurons, Neural Masses and Sources</a> <li><a href="" class=has-arrow >Circuit Models</a> <ul> <li><a href="/course/pages/circuits">Introduction</a> <li><a href="/course/pages/CS_circuit">Biomimetic Corticostriatal assemblies</a> <li><a href="/course/pages/PING_circuit">Pyramidal-Interneuron Gamma network</a> </ul> <li><a href="/course/pages/decision_making">Decision Making</a> <li><a href="/course/pages/learning">Synaptic Plasticity and Reinforcement Learning</a> <li><a href="/course/pages/optimization">Parameter Fitting using Optimization</a> <li><a href="/course/pages/DCM">Parameter fitting using Spectral Dynamic Causal Modeling</a> <li><a href="/course/pages/experimental_design">Experimental Design</a> </ul> </nav> </div> <main id=panel  class="slidout-panel slideout-panel-left"> <div class="toggle-button hamburger hamburger--spin"> <div class=hamburger-box > <div class=hamburger-inner ></div> </div> </div> <h1 class="page title">Parameter Fitting using Spectral Dynamic Causal Modeling</h1> <hr> <div class=franklin-content ><div class=franklin-toc ><ol><li><a href="#introduction">Introduction</a><li><a href="#define_the_model">Define the Model</a><li><a href="#run_the_simulation_and_plot_the_results">Run the Simulation and Plot the Results</a><li><a href="#add_measurement_noise_and_rescale_data">Add Measurement Noise and Rescale Data</a><li><a href="#estimate_and_plot_the_cross-spectral_densities">Estimate and Plot the Cross-spectral Densities</a><li><a href="#model_inference">Model Inference</a><li><a href="#setup_spectral_dcm">Setup Spectral DCM</a><li><a href="#results">Results</a><li><a href="#challenge_problems">Challenge Problems</a><li><a href="#references">References</a></ol></div> <h1 id=parameter_fitting_using_spectral_dynamic_causal_modeling ><a href="#parameter_fitting_using_spectral_dynamic_causal_modeling" class=header-anchor >Parameter Fitting using Spectral Dynamic Causal Modeling</a></h1> <blockquote> <p><strong><em>Jupyter Notebook</em>:</strong> Please work on <code>DCM.ipynb</code>.</p> </blockquote> <iframe width=560  height=315  src="https://www.youtube.com/embed/OEeyks_HIMI?si=1wZRVeAaY9rmdGeI" title="YouTube video player" frameborder=0  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy=strict-origin-when-cross-origin  allowfullscreen></iframe> <h2 id=introduction ><a href="#introduction" class=header-anchor >Introduction</a></h2> <p>Neuroblox provides you with a comprehensive environment for simulations as we have explored previously, but its functionality doesn&#39;t stop there. We will now pivot and turn our attention to a different kind of problem: inferring model parameters, that is solving inverse problems, from time series. The method of choice is one of the most widely spread in imaging neuroscience, spectral Dynamic Causal Modeling &#40;spDCM&#41;&#91;1,2&#93;. In this tutorial we will introduce how to perform a spDCM analysis on simulated data. To do so we roughly reproduce the procedure in the <a href="https://www.fil.ion.ucl.ac.uk/spm/software/spm12/">SPM</a> script <code>DEM_demo_induced_fMRI.m</code> in <a href="https://www.neuroblox.org/">Neuroblox</a>. This work was also presented in Hofmann et al.&#91;2&#93;</p> <p>In this session we will define a circuit of three linear neuronal mass models, all driven by an Ornstein-Uhlenbeck process. We will model fMRI data by a balloon model and BOLD signal on top. After simulation of this simple model we will use spDCM to infer some of the model parameters from the simulation time series.</p> <p><img src="/course/assets/spectral_DCM_illustration.png" alt="spDCM Workflow" /> <em>Figure 1: Workflow for Spectral DCM analysis.</em></p> <p><em>Figure 1</em> describes the procedure we will pursue:</p> <ul> <li><p>define the graph and add blocks &#40;sections A, B and C in the Figure&#41;</p> <li><p>simulate the model, instead we could also use actual data &#40;section D in Figure&#41;</p> <li><p>compute the cross spectral density</p> <li><p>setup the DCM</p> <li><p>estimate parameters</p> <li><p>plot the results</p> </ul> <p>Learning goals</p> <ul> <li><p>perform the entire workflow of an spDCM analysis.</p> <li><p>use observer Blox to simulate experimental measurements.</p> </ul> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> Neuroblox
<span class=hljs-keyword >using</span> LinearAlgebra
<span class=hljs-keyword >using</span> StochasticDiffEq
<span class=hljs-keyword >using</span> DataFrames
<span class=hljs-keyword >using</span> OrderedCollections
<span class=hljs-keyword >using</span> CairoMakie
<span class=hljs-keyword >using</span> ModelingToolkit
<span class=hljs-keyword >using</span> Random
<span class=hljs-keyword >using</span> StatsBase</code></pre> <h2 id=define_the_model ><a href="#define_the_model" class=header-anchor >Define the Model</a></h2> <p>We will define a model of 3 regions. This means first of all to define a graph. To this graph we will add three linear neuronal mass models which constitute the &#40;hidden&#41; neuronal dynamics. These constitute three nodes of the graph. Next we will also need some input that stimulates the activity, we use simple Ornstein-Uhlenbeck blocks to create stochastic inputs. One per region. We want to simulate fMRI signals thus we will need to also add a BalloonModel per region. Note that the Ornstein-Uhlenbeck block will feed into the linear neural mass which in turn will feed into the BalloonModel blox. This needs to be represented by the way we define the edges.</p> <pre><code class="julia hljs">Random.seed!(<span class=hljs-number >17</span>)   <span class=hljs-comment ># set seed for reproducibility</span>

nr = <span class=hljs-number >3</span>             <span class=hljs-comment ># number of regions</span>
g = MetaDiGraph()
regions = [];      <span class=hljs-comment ># list of neural mass blocks to then connect them to each other with an adjacency matrix `A_true`</span></code></pre> <p>Now add the different blocks to each region and connect the blocks within each region. For convenience we use a for loop since the type of blocks belonging to a each region repeat over regions but you could also approach building the system the same way as was shown in previous tutorials:</p> <pre><code class="julia hljs"><span class=hljs-keyword >for</span> i = <span class=hljs-number >1</span>:nr
    region = LinearNeuralMass(;name=<span class=hljs-built_in >Symbol</span>(<span class=hljs-string >&quot;r<span class=hljs-subst >$(i)</span>₊lm&quot;</span>))
    push!(regions, region)          <span class=hljs-comment ># store neural mass model in list. We need this list below. If you haven&#x27;t seen the Julia command `push!` before [see here](http://jlhub.com/julia/manual/en/function/push-exclamation).</span>

    input = OUBlox(;name=<span class=hljs-built_in >Symbol</span>(<span class=hljs-string >&quot;r<span class=hljs-subst >$(i)</span>₊ou&quot;</span>), σ=<span class=hljs-number >0.2</span>, τ=<span class=hljs-number >2</span>)
    add_edge!(g, input =&gt; region, weight=<span class=hljs-number >1</span>/<span class=hljs-number >16</span>)

    measurement = BalloonModel(;name=<span class=hljs-built_in >Symbol</span>(<span class=hljs-string >&quot;r<span class=hljs-subst >$(i)</span>₊bm&quot;</span>)) <span class=hljs-comment >## simulate fMRI signal with BalloonModel which includes the BOLD signal on top of the balloon model dynamics</span>
    add_edge!(g, region =&gt; measurement, weight=<span class=hljs-number >1.0</span>)
<span class=hljs-keyword >end</span></code></pre> <p>Note that <code>weight&#61;1/16</code> in the connection between the OU process and the Neural Mass Blox is taken from SPM12. This stabilizes the balloon model simulation. Alternatively the noise of the Ornstein-Uhlenbeck block or the weight of the edge connecting neuronal activity and balloon model could be reduced to guarantee numerical stability. Next we define the between-region connectivity matrix and connect regions; we use the same matrix as is defined in &#91;3&#93;</p> <pre><code class="julia hljs">A_true = [[-<span class=hljs-number >0.5</span> -<span class=hljs-number >0.2</span> <span class=hljs-number >0</span>]; [<span class=hljs-number >0.4</span> -<span class=hljs-number >0.5</span> -<span class=hljs-number >0.3</span>]; [<span class=hljs-number >0</span> <span class=hljs-number >0.2</span> -<span class=hljs-number >0.5</span>]]</code></pre><pre><code class="plaintext hljs">3×3 Matrix{Float64}:
 -0.5  -0.2   0.0
  0.4  -0.5  -0.3
  0.0   0.2  -0.5</code></pre> <p>Note that in SPM DCM connection matrices column variables denote output from and rows denote inputs to a particular region. This is different from the usual Neuroblox definition of connection matrices. Thus we flip the indices in what follows:</p> <pre><code class="julia hljs"><span class=hljs-keyword >for</span> idx <span class=hljs-keyword >in</span> <span class=hljs-built_in >CartesianIndices</span>(A_true)
    add_edge!(g, regions[idx[<span class=hljs-number >1</span>]] =&gt; regions[idx[<span class=hljs-number >2</span>]], weight=A_true[idx[<span class=hljs-number >2</span>], idx[<span class=hljs-number >1</span>]])   <span class=hljs-comment ># Note the definition of columns as outputs and rows as inputs. For consistency with SPM we keep this notation.</span>
<span class=hljs-keyword >end</span></code></pre> <p>finally we compose the simulation model</p> <pre><code class="julia hljs"><span class=hljs-meta >@named</span> simmodel = system_from_graph(g);</code></pre>
<h2 id=run_the_simulation_and_plot_the_results ><a href="#run_the_simulation_and_plot_the_results" class=header-anchor >Run the Simulation and Plot the Results</a></h2>
<p>setup simulation of the model, time in seconds</p>
<pre><code class="julia hljs">tspan = (<span class=hljs-number >0</span>, <span class=hljs-number >1022</span>)
dt = <span class=hljs-number >2</span>   <span class=hljs-comment ># 2 seconds as measurement interval for fMRI</span>
prob = SDEProblem(simmodel, [], tspan)
sol = solve(prob, ImplicitRKMil(), saveat=dt);</code></pre>
<p>we now want to extract all the variables in our model which carry the tag &quot;measurement&quot;. For this purpose we can use the Neuroblox function <code>get_idx_tagged_vars</code> the observable quantity in our model is the BOLD signal, the variable of the Blox <code>BalloonModel</code> that represents the BOLD signal is tagged with &quot;measurement&quot; tag. other tags that are defined are &quot;input&quot; which denotes variables representing a stimulus, like for instance an <code>OUBlox</code>.</p>
<pre><code class="julia hljs">idx_m = get_idx_tagged_vars(simmodel, <span class=hljs-string >&quot;measurement&quot;</span>)    <span class=hljs-comment ># get index of bold signal</span></code></pre><pre><code class="plaintext hljs">UndefVarError: `get_idx_tagged_vars` not defined in `Main.FD_SANDBOX_2630177278844153205`
Suggestion: check for spelling errors or missing imports.
</code></pre>
<p>plot bold signal time series</p>
<pre><code class="julia hljs">f = Figure()
ax = Axis(f[<span class=hljs-number >1</span>, <span class=hljs-number >1</span>],
    title = <span class=hljs-string >&quot;fMRI time series&quot;</span>,
    xlabel = <span class=hljs-string >&quot;Time [ms]&quot;</span>,
    ylabel = <span class=hljs-string >&quot;BOLD&quot;</span>,
)
lines!(ax, sol, idxs=idx_m)
f</code></pre><pre><code class="plaintext hljs">UndefVarError: `idx_m` not defined in `Main.FD_SANDBOX_2630177278844153205`
Suggestion: check for spelling errors or missing imports.
</code></pre>
<p><span style="color:red;">// Image matching '/assets/pages/DCM/code/fmriseries' not found. //</span></p>
<p>We note that the initial spike is not meaningful and a result of the equilibration of the stochastic process thus we remove it.</p>
<pre><code class="julia hljs">dfsol = DataFrame(sol);</code></pre>
<h2 id=add_measurement_noise_and_rescale_data ><a href="#add_measurement_noise_and_rescale_data" class=header-anchor >Add Measurement Noise and Rescale Data</a></h2>
<pre><code class="julia hljs">data = <span class=hljs-built_in >Matrix</span>(dfsol[:, idx_m .+ <span class=hljs-number >1</span>]);    <span class=hljs-comment ># +1 due to the additional time-dimension in the data frame.</span></code></pre><pre><code class="plaintext hljs">UndefVarError: `idx_m` not defined in `Main.FD_SANDBOX_2630177278844153205`
Suggestion: check for spelling errors or missing imports.
</code></pre>
<p>add measurement noise</p>
<pre><code class="julia hljs">data += randn(size(data))/<span class=hljs-number >4</span>;</code></pre><pre><code class="plaintext hljs">UndefVarError: `data` not defined in `Main.FD_SANDBOX_2630177278844153205`
Suggestion: check for spelling errors or missing imports.
Hint: a global variable of this name may be made accessible by importing BaseDirs in the current active module Main
</code></pre>
<p>center and rescale data &#40;as done in SPM&#41;:</p>
<pre><code class="julia hljs">data .-= mean(data, dims=<span class=hljs-number >1</span>);
data *= <span class=hljs-number >1</span>/std(data[:])/<span class=hljs-number >4</span>;
dfsol = DataFrame(data, :auto);</code></pre><pre><code class="plaintext hljs">UndefVarError: `data` not defined in `Main.FD_SANDBOX_2630177278844153205`
Suggestion: check for spelling errors or missing imports.
Hint: a global variable of this name may be made accessible by importing BaseDirs in the current active module Main
</code></pre>
<p>Add correct names to columns of the data frame</p>
<pre><code class="julia hljs">_, obsvars = get_eqidx_tagged_vars(simmodel, <span class=hljs-string >&quot;measurement&quot;</span>);  <span class=hljs-comment ># get index of equation of bold state</span>
rename!(dfsol, <span class=hljs-built_in >Symbol</span>.(obsvars));</code></pre><pre><code class="plaintext hljs">UndefVarError: `get_eqidx_tagged_vars` not defined in `Main.FD_SANDBOX_2630177278844153205`
Suggestion: check for spelling errors or missing imports.
</code></pre>
<h2 id=estimate_and_plot_the_cross-spectral_densities ><a href="#estimate_and_plot_the_cross-spectral_densities" class=header-anchor >Estimate and Plot the Cross-spectral Densities</a></h2>
<p>We compute the cross-spectral density by fitting a linear model of order <code>p</code> and then compute the csd analytically from the parameters of the multivariate autoregressive model</p>
<pre><code class="julia hljs">p = <span class=hljs-number >8</span>
mar = mar_ml(data, p)   <span class=hljs-comment ># maximum likelihood estimation of the MAR coefficients and noise covariance matrix</span>
ns = size(data, <span class=hljs-number >1</span>)
freq = range(min(<span class=hljs-number >128</span>, ns*dt)^-<span class=hljs-number >1</span>, max(<span class=hljs-number >8</span>, <span class=hljs-number >2</span>*dt)^-<span class=hljs-number >1</span>, <span class=hljs-number >32</span>)
csd = mar2csd(mar, freq, dt^-<span class=hljs-number >1</span>);</code></pre><pre><code class="plaintext hljs">UndefVarError: `mar_ml` not defined in `Main.FD_SANDBOX_2630177278844153205`
Suggestion: check for spelling errors or missing imports.
</code></pre>
<p>Now plot the real part of the cross-spectra. Most part of the signal is in the lower frequencies:</p>
<pre><code class="julia hljs">fig = Figure(size=(<span class=hljs-number >1200</span>, <span class=hljs-number >800</span>))
grid = fig[<span class=hljs-number >1</span>, <span class=hljs-number >1</span>] = GridLayout()
<span class=hljs-keyword >for</span> i = <span class=hljs-number >1</span>:nr
    <span class=hljs-keyword >for</span> j = <span class=hljs-number >1</span>:nr
        <span class=hljs-keyword >if</span> i == <span class=hljs-number >1</span> &amp;&amp; j == <span class=hljs-number >1</span>
            ax = Axis(grid[i, j], xlabel=<span class=hljs-string >&quot;Frequency [Hz]&quot;</span>, ylabel=<span class=hljs-string >&quot;real value of CSD&quot;</span>)
        <span class=hljs-keyword >else</span>
            ax = Axis(grid[i, j])
        <span class=hljs-keyword >end</span>
        lines!(ax, freq, real.(csd[:, i, j]))
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span>
Label(grid[<span class=hljs-number >1</span>, <span class=hljs-number >1</span>:<span class=hljs-number >3</span>, Top()], <span class=hljs-string >&quot;Cross-spectral densities&quot;</span>, valign = :bottom,
    font = :bold,
    fontsize = <span class=hljs-number >32</span>,
    padding = (<span class=hljs-number >0</span>, <span class=hljs-number >0</span>, <span class=hljs-number >5</span>, <span class=hljs-number >0</span>))
fig</code></pre><pre><code class="plaintext hljs">UndefVarError: `freq` not defined in `Main.FD_SANDBOX_2630177278844153205`
Suggestion: check for spelling errors or missing imports.
</code></pre>
<p><p><span style="color:red;">// Image matching '/assets/pages/DCM/code/csd' not found. //</span></p> These cross-spectral densities are the data we use in spectral DCM to fit our model to and perform the inference of connection strengths.</p>
<h2 id=model_inference ><a href="#model_inference" class=header-anchor >Model Inference</a></h2>
<p>We will now assemble a new model that is used for fitting the previous simulations. This procedure is similar to before with the difference that we will define global parameters and use tags such as &#91;tunable&#61;false/true&#93; to define which parameters we will want to estimate. Note that parameters are tunable by default.</p>
<pre><code class="julia hljs">g = MetaDiGraph()
regions = [];   <span class=hljs-comment ># list of neural mass blocks to then connect them to each other with an adjacency matrix `A`</span></code></pre>
<p>Note that parameters are typically defined within a Blox and thus not immediately visible to the user. Since we want some parameters to be shared across several regions we define them outside of the regions. For this purpose use the ModelingToolkit macro <code>@parameters</code> which is used to define symbolic parameters for models. Note that we can set the tunable flag right away thereby defining whether we will include this parameter in the optimization procedure or rather keep it fixed to its predefined value.</p>
<pre><code class="julia hljs"><span class=hljs-meta >@parameters</span> lnκ=<span class=hljs-number >0.0</span> [tunable=<span class=hljs-literal >false</span>] lnϵ=<span class=hljs-number >0.0</span> [tunable=<span class=hljs-literal >false</span>] lnτ=<span class=hljs-number >0.0</span> [tunable=<span class=hljs-literal >false</span>];   <span class=hljs-comment ># lnκ: decay parameter for hemodynamics; lnϵ: ratio of intra- to extra-vascular components, lnτ: transit time scale</span>
<span class=hljs-meta >@parameters</span> C=<span class=hljs-number >1</span>/<span class=hljs-number >16</span> [tunable=<span class=hljs-literal >false</span>];   <span class=hljs-comment ># note that C=1/16 is taken from SPM12 and stabilizes the balloon model simulation. See also comment above.</span></code></pre>
<p>We now define a similar model as above for the simulation but instead of using an actual stimulus Blox we here add ExternalInput which represents a simple linear external input that is not specified any further. We simply say that our model gets some input with a proportional factor <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>. This is mostly only to make sure that our results are consistent with those produced by SPM</p>
<pre><code class="julia hljs"><span class=hljs-keyword >for</span> i = <span class=hljs-number >1</span>:nr
    region = LinearNeuralMass(;name=<span class=hljs-built_in >Symbol</span>(<span class=hljs-string >&quot;r<span class=hljs-subst >$(i)</span>₊lm&quot;</span>))
    push!(regions, region)
    input = ExternalInput(;name=<span class=hljs-built_in >Symbol</span>(<span class=hljs-string >&quot;r<span class=hljs-subst >$(i)</span>₊ei&quot;</span>))
    add_edge!(g, input =&gt; region, weight=C)

    measurement = BalloonModel(;name=<span class=hljs-built_in >Symbol</span>(<span class=hljs-string >&quot;r<span class=hljs-subst >$(i)</span>₊bm&quot;</span>), lnτ=lnτ, lnκ=lnκ, lnϵ=lnϵ) <span class=hljs-comment >## assume fMRI signal and model them with a BalloonModel</span>
    add_edge!(g, region =&gt; measurement, weight=<span class=hljs-number >1.0</span>)
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">UndefVarError: `ExternalInput` not defined in `Main.FD_SANDBOX_2630177278844153205`
Suggestion: check for spelling errors or missing imports.
</code></pre>
<p>Here we define the prior expectation values of the effective connectivity matrix we wish to infer:</p>
<pre><code class="julia hljs">A_prior = <span class=hljs-number >0.01</span>*randn(nr, nr)
A_prior -= diagm(diag(A_prior))    <span class=hljs-comment ># remove the diagonal</span></code></pre><pre><code class="plaintext hljs">3×3 Matrix{Float64}:
  0.0         0.00345049  -0.0122152
  0.0148102   0.0          0.00437472
 -0.00716553  0.00429191   0.0</code></pre>
<p>Since we want to optimize these weights we turn them into symbolic parameters: Add the symbolic weights to the edges and connect regions.</p>
<pre><code class="julia hljs">A = []
<span class=hljs-keyword >for</span> (i, a) <span class=hljs-keyword >in</span> enumerate(vec(A_prior))
    symb = <span class=hljs-built_in >Symbol</span>(<span class=hljs-string >&quot;A<span class=hljs-subst >$(i)</span>&quot;</span>)
    push!(A, only(<span class=hljs-meta >@parameters</span> $symb = a))
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >for</span> (i, idx) <span class=hljs-keyword >in</span> enumerate(<span class=hljs-built_in >CartesianIndices</span>(A_prior))
    <span class=hljs-keyword >if</span> idx[<span class=hljs-number >1</span>] == idx[<span class=hljs-number >2</span>]
        add_edge!(g, regions[idx[<span class=hljs-number >1</span>]] =&gt; regions[idx[<span class=hljs-number >2</span>]], weight=-exp(A[i])/<span class=hljs-number >2</span>)  <span class=hljs-comment >## -exp(A[i])/2: treatement of diagonal elements in SPM12 to make diagonal dominance (see Gershgorin Theorem) more likely but it is not guaranteed</span>
    <span class=hljs-keyword >else</span>
        add_edge!(g, regions[idx[<span class=hljs-number >2</span>]] =&gt; regions[idx[<span class=hljs-number >1</span>]], weight=A[i])
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span>
<span class=hljs-comment ># Avoid simplification of the model in order to be able to exclude some parameters from fitting</span>
<span class=hljs-meta >@named</span> fitmodel = system_from_graph(g, simplify=<span class=hljs-literal >false</span>);</code></pre><pre><code class="plaintext hljs">BoundsError: attempt to access 1-element Vector{Any} at index [2]
</code></pre>
<p>With the function <code>changetune</code> we can provide a dictionary of parameters whose tunable flag should be changed, for instance set to false to exclude them from the optimization procedure. For instance the effective connections that are set to zero in the simulation and the self-connections:</p>
<pre><code class="julia hljs">untune = <span class=hljs-built_in >Dict</span>(A[<span class=hljs-number >3</span>] =&gt; <span class=hljs-literal >false</span>, A[<span class=hljs-number >7</span>] =&gt; <span class=hljs-literal >false</span>, A[<span class=hljs-number >1</span>] =&gt; <span class=hljs-literal >false</span>, A[<span class=hljs-number >5</span>] =&gt; <span class=hljs-literal >false</span>, A[<span class=hljs-number >9</span>] =&gt; <span class=hljs-literal >false</span>)
fitmodel = changetune(fitmodel, untune)           <span class=hljs-comment ># 3 and 7 are not present in the simulation model</span>
fitmodel = structural_simplify(fitmodel)          <span class=hljs-comment ># and now simplify the euqations</span></code></pre><pre><code class="plaintext hljs">UndefVarError: `fitmodel` not defined in `Main.FD_SANDBOX_2630177278844153205`
Suggestion: check for spelling errors or missing imports.
</code></pre>
<h2 id=setup_spectral_dcm ><a href="#setup_spectral_dcm" class=header-anchor >Setup Spectral DCM</a></h2>
<pre><code class="julia hljs">max_iter = <span class=hljs-number >128</span>; <span class=hljs-comment ># maximum number of iterations</span>
<span class=hljs-comment ># attribute initial conditions or default values to dynamic states of our model</span>
sts, _ = get_dynamic_states(fitmodel);</code></pre><pre><code class="plaintext hljs">UndefVarError: `get_dynamic_states` not defined in `Main.FD_SANDBOX_2630177278844153205`
Suggestion: check for spelling errors or missing imports.
</code></pre>
<p>the following step is needed if the model&#39;s Jacobian would give degenerate eigenvalues when expanded around the fixed point 0 &#40;which is the default expansion&#41;. We simply add small random values to avoid this degeneracy:</p>
<pre><code class="julia hljs">perturbedfp = <span class=hljs-built_in >Dict</span>(sts .=&gt; abs.(<span class=hljs-number >10</span>^-<span class=hljs-number >10</span>*rand(length(sts))))     <span class=hljs-comment ># slight noise to avoid issues with Automatic Differentiation.</span></code></pre><pre><code class="plaintext hljs">UndefVarError: `sts` not defined in `Main.FD_SANDBOX_2630177278844153205`
Suggestion: check for spelling errors or missing imports.
</code></pre>
<p>For convenience we can use the default prior function to use standardized prior values as given in SPM:</p>
<pre><code class="julia hljs">pmean, pcovariance, indices = defaultprior(fitmodel, nr)

priors = (μθ_pr = pmean,
          Σθ_pr = pcovariance
         );</code></pre><pre><code class="plaintext hljs">UndefVarError: `defaultprior` not defined in `Main.FD_SANDBOX_2630177278844153205`
Suggestion: check for spelling errors or missing imports.
</code></pre>
<p>Setup hyper parameter prior as well:</p>
<pre><code class="julia hljs">hyperpriors = (Πλ_pr = <span class=hljs-number >128.0</span>*ones(<span class=hljs-number >1</span>, <span class=hljs-number >1</span>),   <span class=hljs-comment ># prior metaparameter precision, needs to be a matrix</span>
               μλ_pr = [<span class=hljs-number >8.0</span>]               <span class=hljs-comment ># prior metaparameter mean, needs to be a vector</span>
              );</code></pre>
<p>To compute the cross spectral densities we need to provide the sampling interval of the time series, the frequency axis and the order of the multivariate autoregressive model:</p>
<pre><code class="julia hljs">csdsetup = (mar_order = p, freq = freq, dt = dt);</code></pre><pre><code class="plaintext hljs">UndefVarError: `freq` not defined in `Main.FD_SANDBOX_2630177278844153205`
Suggestion: check for spelling errors or missing imports.
</code></pre>
<p>Prepare the DCM. This function will setup the computation of the Dynamic Causal Model. The last parameter specifies that we are using fMRI time series &#40;as opposed to LFPs, which is the other modality that is currently available in Neuroblox&#41;.</p>
<pre><code class="julia hljs">(state, setup) = setup_sDCM(dfsol, fitmodel, perturbedfp, csdsetup, priors, hyperpriors, indices, pmean, <span class=hljs-string >&quot;fMRI&quot;</span>);</code></pre><pre><code class="plaintext hljs">UndefVarError: `setup_sDCM` not defined in `Main.FD_SANDBOX_2630177278844153205`
Suggestion: check for spelling errors or missing imports.
</code></pre>
<p>We are now ready to run the optimization procedure&#33; That is we loop over run<em>sDCM</em>iteration&#33; which will alter <code>state</code> after each optimization iteration. It essentially computes the Variational Laplace estimation of expectation and variance of the tunable parameters.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >for</span> iter <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:max_iter
    state.iter = iter
    run_sDCM_iteration!(state, setup)
    print(<span class=hljs-string >&quot;iteration: &quot;</span>, iter, <span class=hljs-string >&quot; - F:&quot;</span>, state.F[<span class=hljs-keyword >end</span>], <span class=hljs-string >&quot; - dF predicted:&quot;</span>, state.dF[<span class=hljs-keyword >end</span>], <span class=hljs-string >&quot;\n&quot;</span>)
    <span class=hljs-keyword >if</span> iter &gt;= <span class=hljs-number >4</span>
        criterion = state.dF[<span class=hljs-keyword >end</span>-<span class=hljs-number >3</span>:<span class=hljs-keyword >end</span>] .&lt; setup.tolerance
        <span class=hljs-keyword >if</span> all(criterion)
            print(<span class=hljs-string >&quot;convergence\n&quot;</span>)
            <span class=hljs-keyword >break</span>
        <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">UndefVarError: `state` not defined in `Main.FD_SANDBOX_2630177278844153205`
Suggestion: check for spelling errors or missing imports.
Hint: a global variable of this name may be made accessible by importing BaseDirs in the current active module Main
</code></pre>
<p>Note that the output <code>F</code> is the free energy at each iteration step and <code>dF</code> is the predicted change of free energy at each step which approximates the actual free energy change and is used as stopping criterion by requiring that it does not excede the <code>tolerance</code> level for 4 consecutive times.</p>
<h2 id=results ><a href="#results" class=header-anchor >Results</a></h2>
<p>Free energy is the objective function of the optimization scheme of spectral DCM. Note that in the machine learning literature this it is called Evidence Lower Bound &#40;ELBO&#41;. Plot the free energy evolution over optimization iterations to see how the algorithm converges towards a &#40;potentially local&#41; optimum:</p>
<pre><code class="julia hljs">f1 = freeenergy(state)</code></pre><pre><code class="plaintext hljs">UndefVarError: `freeenergy` not defined in `Main.FD_SANDBOX_2630177278844153205`
Suggestion: check for spelling errors or missing imports.
</code></pre>
<p><span style="color:red;">// Image matching '/assets/pages/DCM/code/freeenergy' not found. //</span></p>
<p>Plot the estimated posterior of the effective connectivity and compare that to the true parameter values. Bar height are the posterior mean and error bars are the standard deviation of the posterior.</p>
<pre><code class="julia hljs">f2 = ecbarplot(state, setup, A_true)
axislegend(position=:lt)</code></pre><pre><code class="plaintext hljs">UndefVarError: `ecbarplot` not defined in `Main.FD_SANDBOX_2630177278844153205`
Suggestion: check for spelling errors or missing imports.
</code></pre>
<p><span style="color:red;">// Image matching '/assets/pages/DCM/code/ecbar' not found. //</span></p>
<h2 id=challenge_problems ><a href="#challenge_problems" class=header-anchor >Challenge Problems</a></h2>
<ul>
<li><p><strong>Explore susceptibility with respect to noise.</strong> Run the script again with a different random seed and observe how the results change. Given that we didn’t change any parameters of the ground truth, what is your take on parameter inference with this setup? How reliable is model selection based on free energy &#40;compare the different free energies of the models and their respective parameter values with ground truth&#41;?</p>

<li><p><strong>Averaging over patients.</strong> Now repeat the simulation and inference again with 10 different seeds &#40;you can just remove the number in Random.seed&#40;&#41; to use current time stamps as seeds&#41; and store the results of each run, such that you get several models based on the same ground truth but with different instances of the noise. Can you extract the average value of the effective connectivity from the ensemble?</p>

<li><p>Changing neuronal dynamics model. Now change the model and test the whole procedure with a different underlying neuronal mass model, for instance the Jansen-Rit model. Note that there are no default priors for the Jansen-Rit model, you will have to provide priors for the extra parameters or remove them from the optimization procedure by setting their tunable to false.</p>

</ul>
<h2 id=references ><a href="#references" class=header-anchor >References</a></h2>
<ul>
<li><p>&#91;1&#93; <a href="https://doi.org/10.1162/netn_a_00348">Novelli, Leonardo, Karl Friston, and Adeel Razi. “Spectral Dynamic Causal Modeling: A Didactic Introduction and Its Relationship with Functional Connectivity.” Network Neuroscience 8, no. 1 &#40;April 1, 2024&#41;: 178–202.</a> <br /></p>

<li><p>&#91;2&#93; <a href="https://doi.org/10.1101/2023.10.27.564407">Hofmann, David, Anthony G. Chesebro, Chris Rackauckas, Lilianne R. Mujica-Parodi, Karl J. Friston, Alan Edelman, and Helmut H. Strey. “Leveraging Julia’s Automated Differentiation and Symbolic Computation to Increase Spectral DCM Flexibility and Speed.” bioRxiv: The Preprint Server for Biology, 2023.</a> <br /></p>

<li><p>&#91;3&#93; <a href="https://linkinghub.elsevier.com/retrieve/pii/S1053811913012135">Friston, Karl J., Joshua Kahan, Bharat Biswal, and Adeel Razi. “A DCM for Resting State fMRI.” NeuroImage 94 &#40;July 2014&#41;: 396–407.</a></p>

</ul>

<div class=page-foot >
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Neuroblox Inc. Last modified: July 22, 2025.
    Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
</div>
</div>
  </main> 
  <script src="/course/libs/vela/metisMenu.min.js"></script>
  <script src="/course/libs/vela/slideout.min.js"></script>
  
    



  
  
    <script src="/course/libs/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();hljs.configure({tabReplace: '    '});</script>