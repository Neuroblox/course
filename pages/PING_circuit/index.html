<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/course/libs/katex/katex.min.css"> <link rel=stylesheet  href="/course/libs/highlight/styles/github.min.css"> <link href="/course/css/franklin.css" rel=stylesheet > <link href="/course/css/vela.css" rel=stylesheet > <script src="/course/libs/vela/jquery.min.js"></script> <link rel=icon  href="/course/assets/NB_favicon.png"> <title>Neuroblox course</title> <div class="main-nav slideout-menu slideout-menu-left" id=menu > <div class=flex-container > <span class=sidebar-brand > <h3 style='font-size: 25px'>Neuroblox course</h3> </span> </div> <nav class=sidebar-nav > <ul class=metismenu  id=metismenu  > <li><a href="/course/index.html">Home</a> <li><a href="/course/pages/getting_started">Getting Started</a> <li><a href="/course/pages/intro_julia">Introduction to Julia</a> <li><a href="/course/pages/intro_diffeq">Differential Equations with ModelingToolkit</a> <li><a href="/course/pages/intro_plot">Plotting with Makie</a> <li><a href="/course/pages/blox_connections">Blox and Connections in Neuroblox</a> <li><a href="/course/pages/neuron_mass">Neurons, Neural Masses and Sources</a> <li><a href="" class=has-arrow >Circuit Models</a> <ul> <li><a href="/course/pages/circuits">Introduction</a> <li><a href="/course/pages/CS_circuit">Biomimetic Corticostriatal assemblies</a> <li><a href="/course/pages/PING_circuit">Pyramidal-Interneuron Gamma network</a> </ul> <li><a href="/course/pages/decision_making">Decision Making</a> <li><a href="/course/pages/learning">Synaptic Plasticity and Reinforcement Learning</a> <li><a href="/course/pages/optimization">Parameter Fitting using Optimization</a> <li><a href="/course/pages/DCM">Parameter fitting using Spectral Dynamic Causal Modeling</a> </ul> </nav> </div> <main id=panel  class="slidout-panel slideout-panel-left"> <div class="toggle-button hamburger hamburger--spin"> <div class=hamburger-box > <div class=hamburger-inner ></div> </div> </div> <h1 class="page title">Pyramidal-Interneuron Gamma network</h1> <hr> <div class=franklin-content ><div class=franklin-toc ><ol><li><a href="#import_the_necessary_packages">Import the necessary packages</a><li><a href="#initialization">Initialization</a><li><a href="#define_the_neurons">Define the neurons</a><li><a href="#define_the_graph_of_network_connections">Define the graph of network connections</a><li><a href="#alternative_graph_creation">Alternative graph creation</a><li><a href="#simulate_the_network">Simulate the network</a><li><a href="#references">References</a></ol></div> <h1 id=pyramidal-interneuron_gamma_network ><a href="#pyramidal-interneuron_gamma_network" class=header-anchor >Pyramidal-Interneuron Gamma network</a></h1> <blockquote> <p><strong><em>Jupyter Notebook</em>:</strong> Please work on <code>PING_circuit.ipynb</code>.</p> </blockquote> <h1 id=introduction ><a href="#introduction" class=header-anchor >Introduction</a></h1> <p>This tutorial provides a simple example of how to use the Neuroblox package to simulate a <a href="https://direct.mit.edu/neco/article-abstract/17/3/557/6926/Effects-of-Noisy-Drive-on-Rhythms-in-Networks-of?redirectedFrom&#61;fulltext">pyramidal-interneuron gamma &#40;PING&#41; network</a>. These networks are generally useful in modeling cortical oscillations and are used in a variety of contexts. This particular example is based on Börgers, Epstein, and Kopell &#91;1&#93; and is a simple example of how to replicate their initial network in Neuroblox.</p> <h1 id=conceptual_definition ><a href="#conceptual_definition" class=header-anchor >Conceptual definition</a></h1> <p>The PING network is a simple model of a cortical network that consists of two populations of neurons: excitatory and inhibitory. We omit the detailed equations of the neurons here, but note they are Hodgkin-Huxley-like equations with a few modifications. Excitatory neurons are reduced Traub-Miles cells &#91;2&#93; and inhibitory neurons are Wang-Buzasaki cells &#91;3&#93;. Both follow Hodgkin-Huxley formalism, i.e., the membrane voltage is governed by the sum of the currents through the sodium, potassium, and leak channels, along with external drive, such that:</p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi>C</mi><mfrac><mrow><mi>d</mi><mi>V</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo>=</mo><msub><mi>g</mi><mtext>Na</mtext></msub><msup><mi>m</mi><mn>3</mn></msup><mi>h</mi><mo stretchy=false >(</mo><msub><mi>V</mi><mtext>Na</mtext></msub><mo>−</mo><mi>V</mi><mo stretchy=false >)</mo><mo>+</mo><msub><mi>g</mi><mtext>K</mtext></msub><msup><mi>n</mi><mn>4</mn></msup><mo stretchy=false >(</mo><msub><mi>V</mi><mtext>K</mtext></msub><mo>−</mo><mi>V</mi><mo stretchy=false >)</mo><mo>+</mo><msub><mi>g</mi><mtext>L</mtext></msub><mo stretchy=false >(</mo><msub><mi>V</mi><mtext>L</mtext></msub><mo>−</mo><mi>V</mi><mo stretchy=false >)</mo><mo>+</mo><msub><mi>I</mi><mtext>ext</mtext></msub></mrow><annotation encoding="application/x-tex"> C \frac{dV}{dt} = g_{\text{Na}} m^3 h (V_{\text{Na}} - V) + g_\text{K} n^4 (V_\text{K} - V) + g_\text{L} (V_\text{L} - V) + I_{\text{ext}} </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.3714em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1.1141em;vertical-align:-0.25em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">Na</span></span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mord ><span class="mord mathnormal">m</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord mathnormal">h</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">Na</span></span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1.1141em;vertical-align:-0.25em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">K</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mord ><span class="mord mathnormal">n</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">K</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">L</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">L</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.8333em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">ext</span></span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> <p>For full details of the model, see Eq. 12-14 on p. 7 of the SI Appendix of Börgers et al. &#91;1&#93;. Figure 1 shows a visual representation of the network structure and which neurons receive the driving input: <img src="/course/assets/basic_ping_illustration.png" alt="PING network structure" /> <em>Figure 1: Structure of the the PING network.</em></p> <h1 id=model_setup ><a href="#model_setup" class=header-anchor >Model setup</a></h1> <p>This section sets up the model parameters and the network structure. The network consists of 200 neurons: 40 driven excitatory neurons, 120 other excitatory neurons, and 40 inhibitory neurons. The network is set up as a directed graph with excitatory neurons driving inhibitory neurons and vice versa, with self-inhibition but not self-excitation present.</p> <h2 id=import_the_necessary_packages ><a href="#import_the_necessary_packages" class=header-anchor >Import the necessary packages</a></h2> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> Neuroblox
<span class=hljs-keyword >using</span> OrdinaryDiffEq
<span class=hljs-keyword >using</span> Distributions
<span class=hljs-keyword >using</span> Random
<span class=hljs-keyword >using</span> CairoMakie</code></pre> <h2 id=initialization ><a href="#initialization" class=header-anchor >Initialization</a></h2> <p>Set the random seed to reproduce the plots as shown here exactly. If you want to probe how random variability changes the network, simply omit this line.</p> <pre><code class="julia hljs">Random.seed!(<span class=hljs-number >42</span>);</code></pre>
<p>Setup the hyperparameters for the PING network simulation. The comments note where these parameters are taken from in the Börgers et al. paper &#91;1&#93; or if they were manually tuned for this particular simulation.</p>
<pre><code class="julia hljs">μ_E = <span class=hljs-number >0.8</span> <span class=hljs-comment >## mean of the excitatory neurons&#x27; external current, manually tuned from the value on p. 8 of the Appendix</span>
σ_E = <span class=hljs-number >0.15</span> <span class=hljs-comment >## standard deviation of the excitatory neurons&#x27; external current, given on p. 8 of the Appendix</span>
μ_I = <span class=hljs-number >0.8</span> <span class=hljs-comment >## mean of the inhibitory neurons&#x27; external current, given on p. 9 of the Appendix</span>
σ_I = <span class=hljs-number >0.08</span> <span class=hljs-comment >## standard deviation of the inhibitory neurons&#x27; external current, given on p. 9 of the Appendix</span>

NE_driven = <span class=hljs-number >40</span> <span class=hljs-comment >## number of driven excitatory neurons, given on p. 8 of the Appendix. Note all receive constant rather than half stochastic drives.</span>
NE_other = <span class=hljs-number >120</span> <span class=hljs-comment >## number of non-driven excitatory neurons, given in the Methods section</span>
NI_driven = <span class=hljs-number >40</span> <span class=hljs-comment >## number of inhibitory neurons (all driven), given in the Methods section</span>
N_total = NE_driven + NE_other + NI_driven <span class=hljs-comment >## total number of neurons in the network</span>

N = N_total <span class=hljs-comment >## convenience redefinition to improve the readability of the connection weights</span>
g_II = <span class=hljs-number >0.2</span> <span class=hljs-comment >## inhibitory-inhibitory connection weight, given on p. 8 of the Appendix</span>
g_IE = <span class=hljs-number >0.6</span> <span class=hljs-comment >## inhibitory-excitatory connection weight, given on p. 8 of the Appendix</span>
g_EI = <span class=hljs-number >0.8</span>; <span class=hljs-comment >## excitatory-inhibitory connection weight, manually tuned from values given on p. 8 of the Appendix</span></code></pre>
<p>Finally, setup the driving currents. All neurons receive a base external current, and the inhibitory and driven excitatory populations receive a second external stimulus current. The undriven excitatory neurons receive a small addition to the base current in lieu of the stochastic current in the original implementation. There is also an external inhibitory bath for the inhibitory neurons - for the importance of this bath see the SI Appendix of Börgers et al. &#91;1&#93;. These currents are specified as distributions using the syntax from <a href="https://juliastats.org/Distributions.jl/stable/starting/">Distributions.jl.</a> The advantage to this is that a distribution can be given to a call of <code>rand&#40;&#41;</code> and the random number will be drawn from the specified distribution. We&#39;ll use this call during the neuron creation step below.</p>
<pre><code class="julia hljs">I_base = Normal(<span class=hljs-number >0</span>, <span class=hljs-number >0.1</span>) <span class=hljs-comment >## base external current for all neurons</span>
I_driveE = Normal(μ_E, σ_E) <span class=hljs-comment >## External current for driven excitatory neurons</span>
I_driveI = Normal(μ_I, σ_I) <span class=hljs-comment >## External current for driven inhibitory neurons</span>
I_undriven = Normal(<span class=hljs-number >0</span>, <span class=hljs-number >0.4</span>) <span class=hljs-comment >## Additional noise current for undriven excitatory neurons. Manually tuned.</span>
I_bath = -<span class=hljs-number >0.7</span>; <span class=hljs-comment >## External inhibitory bath for inhibitory neurons - value from p. 11 of the SI Appendix</span></code></pre>
<h1 id=creating_a_network_in_neuroblox ><a href="#creating_a_network_in_neuroblox" class=header-anchor >Creating a network in Neuroblox</a></h1>
<p>Creating and running a network of neurons in Neuroblox consists of three steps: defining the neurons, defining the graph of connections between the neurons, and simulating the system represented by the graph.</p>
<h2 id=define_the_neurons ><a href="#define_the_neurons" class=header-anchor >Define the neurons</a></h2>
<p>The neurons from Börgers et al. &#91;1&#93; are implemented in Neuroblox as <code>PINGNeuronExci</code> and <code>PINGNeuronInhib</code>. We can specify their initial current drives and create the neurons as follows:</p>
<pre><code class="julia hljs">exci_driven = [PINGNeuronExci(name=<span class=hljs-built_in >Symbol</span>(<span class=hljs-string >&quot;ED<span class=hljs-variable >$i</span>&quot;</span>), I_ext=rand(I_driveE) + rand(I_base)) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:NE_driven] <span class=hljs-comment >## In-line loop to create the driven excitatory neurons, named ED1, ED2, etc.</span>
exci_other  = [PINGNeuronExci(name=<span class=hljs-built_in >Symbol</span>(<span class=hljs-string >&quot;EO<span class=hljs-variable >$i</span>&quot;</span>), I_ext=rand(I_base) + rand(I_undriven)) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:NE_other] <span class=hljs-comment >## In-line loop to create the undriven excitatory neurons, named EO1, EO2, etc.</span>
exci        = [exci_driven; exci_other] <span class=hljs-comment >## Concatenate the driven and undriven excitatory neurons into a single vector for convenience</span>
inhib       = [PINGNeuronInhib(name=<span class=hljs-built_in >Symbol</span>(<span class=hljs-string >&quot;ID<span class=hljs-variable >$i</span>&quot;</span>), I_ext=rand(I_driveI) + rand(I_base) + I_bath) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:NI_driven]; <span class=hljs-comment >## In-line loop to create the inhibitory neurons, named ID1, ID2, etc.</span></code></pre>
<blockquote>
<p><strong><em>NOTE</em>:</strong> If you want to explore the details of these Bloxs, try typing <code>?PINGNeuronExci</code> or <code>?PINGNeuronInhib</code> in your Julia REPL to see the full details of the blocks. If you really want to dig into the details, type <code>@edit PINGNeuronExci&#40;&#41;</code> to open the source code and see how the equations are written.</p>
</blockquote>
<h2 id=define_the_graph_of_network_connections ><a href="#define_the_graph_of_network_connections" class=header-anchor >Define the graph of network connections</a></h2>
<p>This portion illustrates how we go about creating a network of neuronal connections.</p>
<pre><code class="julia hljs">g = MetaDiGraph() <span class=hljs-comment >## Initialize the graph</span>

<span class=hljs-keyword >for</span> ne ∈ exci
    <span class=hljs-keyword >for</span> ni ∈ inhib
        add_edge!(g, ne =&gt; ni; weight=g_EI/N) <span class=hljs-comment >## Add the E -&gt; I connections</span>
        add_edge!(g, ni =&gt; ne; weight=g_IE/N) <span class=hljs-comment >## Add the I -&gt; E connections</span>
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >for</span> ni1 ∈ inhib
    <span class=hljs-keyword >for</span> ni2 ∈ inhib
        add_edge!(g, ni1 =&gt; ni2; weight=g_II/N); <span class=hljs-comment >## Add the I -&gt; I connections</span>
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span></code></pre>
<h2 id=alternative_graph_creation ><a href="#alternative_graph_creation" class=header-anchor >Alternative graph creation</a></h2>
<p>If you are creating a very large network of neurons, it may be more efficient to add all of the nodes first and then all of the edges via an adjacency matrix. To illustrate this, here is <strong>an alternative to the graph construction we have just performed above</strong> that will initialize the same graph.</p>
<pre><code class="julia hljs">g = MetaDiGraph() <span class=hljs-comment >## Initialize the graph</span>
add_blox!.(<span class=hljs-built_in >Ref</span>(g), [exci; inhib]) <span class=hljs-comment >## Add all the neurons to the graph</span>
adj = zeros(N_total, N_total) <span class=hljs-comment >## Initialize the adjacency matrix</span>
<span class=hljs-keyword >for</span> i ∈ <span class=hljs-number >1</span>:NE_driven + NE_other
    <span class=hljs-keyword >for</span> j ∈ <span class=hljs-number >1</span>:NI_driven
        adj[i, NE_driven + NE_other + j] = g_EI/N
        adj[NE_driven + NE_other + j, i] = g_IE/N
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span>
<span class=hljs-keyword >for</span> i ∈ <span class=hljs-number >1</span>:NI_driven
    <span class=hljs-keyword >for</span> j ∈ <span class=hljs-number >1</span>:NI_driven
        adj[NE_driven + NE_other + i, NE_driven + NE_other + j] = g_II/N
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span>
create_adjacency_edges!(g, adj);</code></pre>
<h2 id=simulate_the_network ><a href="#simulate_the_network" class=header-anchor >Simulate the network</a></h2>
<p>Now that we have the neurons and the graph, we can simulate the network. We use the <code>system_from_graph</code> function to create a system of ODEs from the graph and then solve it. We choose to solve this system using the <code>Tsit5&#40;&#41;</code> solver. If you&#39;re coming from Matlab, this is a more efficient solver analogous to <code>ode45</code>. It&#39;s a good first try for systems that aren&#39;t really stiff. If you want to try other solvers, we&#39;d recommend trying with <code>Vern7&#40;&#41;</code> &#40;higher precision but still efficient&#41;. If you&#39;re <strong>really</strong> interested in solver choices, one of the great things about Julia is the <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/">wide variety of solvers available.</a></p>
<pre><code class="julia hljs">tspan = (<span class=hljs-number >0.0</span>, <span class=hljs-number >300.0</span>) <span class=hljs-comment >## Time span for the simulation - run for 300ms to match the Börgers et al. [1] Figure 1.</span>
<span class=hljs-meta >@named</span> sys = system_from_graph(g, graphdynamics=<span class=hljs-literal >true</span>)
prob = ODEProblem(sys, [], tspan) <span class=hljs-comment >## Create the problem to solve</span>
sol = solve(prob, Tsit5(), saveat=<span class=hljs-number >0.1</span>); <span class=hljs-comment >## Solve the problem and save at 0.1ms resolution.</span></code></pre>
<blockquote>
<p><strong><em>NOTE</em>:</strong> Setting <code>graphdynamics&#61;true</code> will enable an alternative compilation mode for the neural system. Not every model is compatible with GraphDynamics.jl &#91;4&#93; yet, but for ones that are compatible, it is usually significantly faster to compile. This option will make the biggest difference when you care about very large numbers of neurons, or if you are running the same model with small changes to the number of neurons or connectivity graph many times.</p>
</blockquote>
<h1 id=plotting_the_results ><a href="#plotting_the_results" class=header-anchor >Plotting the results</a></h1>
<p>Now that we have a whole simulation, let&#39;s plot the results and see how they line up with the original figures. We&#39;re looking to reproduce the dynamics shown in Figure 1 of Börgers et al. &#91;1&#93;. To create raster plots in Neuroblox for the excitatory and inhibitory populations, it is as simple as:</p>
<pre><code class="julia hljs">fig = Figure()
rasterplot(fig[<span class=hljs-number >1</span>,<span class=hljs-number >1</span>], exci, sol; threshold=<span class=hljs-number >20.0</span>, title=<span class=hljs-string >&quot;Excitatory Neurons&quot;</span>)
rasterplot(fig[<span class=hljs-number >2</span>,<span class=hljs-number >1</span>], inhib, sol; threshold=<span class=hljs-number >20.0</span>, title=<span class=hljs-string >&quot;Inhibitory Neurons&quot;</span>)
fig</code></pre>
<img src="/course/assets/pages/PING_circuit/code/output/ping_raster.svg" alt="">
<p>The upper panel should show the dynamics in Figure 1.C, with a clear population of excitatory neurons firing together from the external driving current, and the other excitatory neurons exhibiting more stochastic bursts. The lower panel should show the dynamics in Figure 1.A, with the inhibitory neurons firing in a more synchronous manner than the excitatory neurons.</p>
<h1 id=conclusion ><a href="#conclusion" class=header-anchor >Conclusion</a></h1>
<p>And there you have it&#33; A complete PING demonstration that reproduces the dynamics of a published paper in a matter of 30 seconds, give or take. Have fun making your own&#33;</p>
<blockquote>
<p><strong><em>Exercise:</em></strong> You might have noticed that the excitatory and inhibitory populations become slightly desynchronized by the end of the simulation, unlike in the original paper. This is because of slight differences in how we implement the excitatory drive and inhibitory bath, which adjusts the overall E/I balance. Try increasing the inhibitory bath or decreasing the percentage of excitatory neurons that receive input and see how this affects the synchrony&#33;</p>
</blockquote>
<h2 id=references ><a href="#references" class=header-anchor >References</a></h2>
<ul>
<li><p>&#91;1&#93; Börgers C, Epstein S, Kopell NJ. Gamma oscillations mediate stimulus competition and attentional selection in a cortical network model. Proc Natl Acad Sci U S A. 2008 Nov 18;105&#40;46&#41;:18023-8. DOI: <a href="https://www.doi.org/10.1073/pnas.0809511105">10.1073/pnas.0809511105</a>.</p>

<li><p>&#91;2&#93; Traub, RD, Miles, R. Neuronal Networks of the Hippocampus. Cambridge University Press, Cambridge, UK, 1991. DOI: <a href="https://www.doi.org/10.1017/CBO9780511895401">10.1017/CBO9780511895401</a></p>

<li><p>&#91;3&#93; Wang, X-J, Buzsáki, G. Gamma oscillation by synaptic inhibition in a hippocampal interneuronal network model. J. Neurosci., 16:6402–6413, 1996. DOI: <a href="https://www.doi.org/10.1523/JNEUROSCI.16-20-06402.1996">10.1523/JNEUROSCI.16-20-06402.1996</a></p>

<li><p>&#91;4&#93; Protter, M. &#40;2024&#41;. GraphDynamics.jl – Efficient dynamics of interacting collections of modular subsystems &#40;v0.2.2&#41;. Zenodo. https://doi.org/10.5281/zenodo.14183153</p>

</ul>

<div class=page-foot >
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Neuroblox Inc. Last modified: February 17, 2025.
    Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
</div>
</div>
  </main> 
  <script src="/course/libs/vela/metisMenu.min.js"></script>
  <script src="/course/libs/vela/slideout.min.js"></script>
  
    



  
  
    <script src="/course/libs/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();hljs.configure({tabReplace: '    '});</script>